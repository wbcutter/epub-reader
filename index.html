<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <title>EPUB Reader</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pica/9.0.1/pica.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #fef6f8;
            color: #333;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
        }

        .header {
            background: linear-gradient(135deg, #ff6b9d 0%, #c94b7f 100%);
            padding: 8px 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #ff85a6;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            height: 45px;
            transition: transform 0.3s;
        }

        .header.hidden {
            transform: translateY(-100%);
        }

        .header h1 {
            font-size: 0.95em;
            color: #fff;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 200px;
            text-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }

        .controls {
            display: flex;
            gap: 5px;
            align-items: center;
        }

        .btn {
            background: rgba(255, 255, 255, 0.9);
            color: #ff6b9d;
            border: none;
            padding: 5px 10px;
            border-radius: 15px;
            cursor: pointer;
            font-size: 0.75em;
            transition: all 0.2s;
            white-space: nowrap;
            font-weight: 500;
        }

        .btn:hover {
            background: #fff;
            box-shadow: 0 2px 8px rgba(255, 107, 157, 0.3);
            transform: translateY(-1px);
        }

        .btn.active {
            background: #ff6b9d;
            color: #fff;
        }

        .upload-overlay {
            position: fixed;
            inset: 0;
            background: linear-gradient(135deg, #fef6f8 0%, #ffe6f0 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            flex-direction: column;
            gap: 30px;
            cursor: pointer;
        }

        .upload-overlay.hidden {
            display: none;
        }

        .upload-content {
            text-align: center;
            pointer-events: none;
        }

        .upload-icon {
            font-size: 5em;
            margin-bottom: 20px;
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-20px); }
        }

        .upload-content h2 {
            color: #ff6b9d;
            margin-bottom: 15px;
            font-size: 2em;
        }

        .upload-content p {
            color: #999;
            font-size: 1.1em;
            margin: 10px 0;
        }

        .url-input-box {
            background: rgba(255, 255, 255, 0.9);
            padding: 25px;
            border-radius: 15px;
            max-width: 600px;
            width: 90%;
            pointer-events: auto;
        }

        .url-input-box h3 {
            color: #ff6b9d;
            margin-bottom: 15px;
            font-size: 1.1em;
        }

        .url-input-box input {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #ff85a6;
            border-radius: 20px;
            font-size: 0.9em;
            outline: none;
            margin-bottom: 10px;
        }

        .file-input {
            display: none;
        }

        .viewer-container {
            position: fixed;
            top: 45px;
            left: 0;
            right: 0;
            bottom: 40px;
            display: flex;
            background: #fef6f8;
            transition: top 0.3s, bottom 0.3s;
        }

        .viewer-container.immersive {
            top: 0;
            bottom: 0;
        }

        .sidebar {
            width: 0;
            background: #fff;
            border-right: 2px solid #ffe6f0;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 0;
            transition: width 0.3s, padding 0.3s;
            box-shadow: 2px 0 10px rgba(255, 107, 157, 0.1);
        }

        .sidebar.visible {
            width: 250px;
            padding: 12px;
        }

        .sidebar::-webkit-scrollbar {
            width: 6px;
        }

        .sidebar::-webkit-scrollbar-thumb {
            background: #ff85a6;
            border-radius: 3px;
        }

        .sidebar h3 {
            color: #ff6b9d;
            margin-bottom: 12px;
            font-size: 0.9em;
            display: none;
        }

        .sidebar.visible h3 {
            display: block;
        }

        #thumbnailList {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .chapter-thumb {
            background: #fef6f8;
            border-radius: 8px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s;
            padding: 8px;
        }

        .chapter-thumb:hover {
            border-color: #ff85a6;
            transform: translateX(5px);
        }

        .chapter-thumb.active {
            border-color: #ff6b9d;
            background: #ffe6f0;
        }

        .chapter-number {
            color: #ff6b9d;
            font-weight: 600;
            font-size: 0.75em;
            margin-bottom: 4px;
        }

        .chapter-preview {
            color: #666;
            font-size: 0.7em;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* MAIN VIEWER - Background hồng cho TẤT CẢ */
        .main-viewer {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: #fef6f8;
            padding: 15px;
        }

        .main-viewer::-webkit-scrollbar {
            width: 8px;
        }

        .main-viewer::-webkit-scrollbar-track {
            background: #fef6f8;
        }

        .main-viewer::-webkit-scrollbar-thumb {
            background: #ff85a6;
            border-radius: 4px;
        }

        /* NOVEL MODE - có card trắng */
        .main-viewer.novel-mode .content-container {
            width: 100%;
            max-width: 900px;
        }

        /* MANGA MODE - KHÔNG padding, ảnh dính liền */
        .main-viewer.manga-mode {
            padding: 0; /* Không padding */
            background: #2a2a2a; /* Nền tối cho manga */
        }

        /* MANGA MODE PC - ảnh giới hạn width, căn giữa */
        @media (min-width: 769px) {
            .main-viewer.manga-mode .content-container {
                width: 100%;
                max-width: 900px; /* Giới hạn width trên PC */
                margin: 0 auto;
            }
        }

        /* MANGA MODE Mobile - ảnh full width */
        @media (max-width: 768px) {
            .main-viewer.manga-mode .content-container {
                width: 100%;
                max-width: none;
            }
        }

        /* MANGA PAGE - KHÔNG có card, ảnh dính liền */
        .manga-page {
            background: transparent; /* Không background */
            margin: 0; /* Không margin, ảnh dính liền */
            padding: 0; /* Không padding */
            line-height: 0;
            width: 100%;
            display: block;
        }

        .manga-page img,
        .manga-page svg {
            width: 100%;
            height: auto;
            display: block;
            margin: 0;
            padding: 0;
        }

        .manga-page .placeholder {
            width: 100%;
            min-height: 600px;
            background: rgba(255, 255, 255, 0.05);
            display: flex;
            align-items: center;
            justify-content: center;
            color: #ff85a6;
        }

        /* NOVEL CHAPTER - CÓ card trắng bao quanh */
        .novel-chapter {
            background: #fff;
            color: #333;
            padding: 40px;
            margin-bottom: 20px;
            font-size: 1.1em;
            line-height: 1.9;
            user-select: text;
            -webkit-user-select: text;
            border-radius: 10px;
            box-shadow: 0 2px 15px rgba(255, 107, 157, 0.1);
            scroll-margin-top: 60px;
        }

        .novel-chapter h1,
        .novel-chapter h2,
        .novel-chapter h3 {
            margin-top: 1.5em;
            margin-bottom: 0.5em;
            color: #ff6b9d;
            font-weight: 600;
        }

        .novel-chapter h1 { font-size: 1.8em; }
        .novel-chapter h2 { font-size: 1.4em; }
        .novel-chapter h3 { font-size: 1.2em; }

        .novel-chapter p {
            margin-bottom: 1em;
            text-align: justify;
            text-indent: 2em;
        }

        .novel-chapter img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 1.5em auto;
            border-radius: 8px;
        }

        .novel-chapter a {
            color: #ff6b9d;
            cursor: pointer;
        }

        [id] {
            scroll-margin-top: 80px;
        }

        .footer {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(135deg, #ff6b9d 0%, #c94b7f 100%);
            padding: 6px 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-top: 2px solid #ff85a6;
            z-index: 1000;
            height: 40px;
            transition: transform 0.3s;
        }

        .footer.hidden {
            transform: translateY(100%);
        }

        .page-info {
            font-size: 0.8em;
            color: #fff;
            font-weight: 500;
        }

        .footer-controls {
            display: flex;
            gap: 4px;
        }

        .stats {
            position: fixed;
            top: 50px;
            right: 15px;
            background: rgba(255, 255, 255, 0.95);
            padding: 10px 12px;
            border-radius: 10px;
            font-size: 0.75em;
            z-index: 999;
            border: 2px solid #ffe6f0;
            line-height: 1.8;
            color: #666;
            box-shadow: 0 2px 10px rgba(255, 107, 157, 0.2);
            transition: transform 0.3s;
        }

        .stats.hidden {
            transform: translateX(120%);
        }

        .progress-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: rgba(0, 0, 0, 0.3);
            z-index: 1001;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff1744, #ff5252);
            width: 0%;
            transition: width 0.3s;
            box-shadow: 0 0 10px rgba(255, 23, 68, 0.6);
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .spinner {
            border: 3px solid #ffe6f0;
            border-top: 3px solid #ff6b9d;
            border-radius: 50%;
            width: 35px;
            height: 35px;
            animation: spin 0.8s linear infinite;
            margin: 0 auto;
        }

        @media (max-width: 768px) {
            .novel-chapter {
                padding: 25px;
                font-size: 1em;
            }
        }
    </style>
</head>
<body>
    <div class="upload-overlay" id="uploadOverlay">
        <div class="upload-content">
            <div class="upload-icon">📚</div>
            <h2>EPUB Reader</h2>
            <p>Kéo thả file EPUB hoặc nhấn để chọn file</p>
        </div>

        <div class="url-input-box">
            <h3>📎 Tải từ URL</h3>
            <input type="text" id="urlInput" placeholder="https://example.com/book.epub">
            <button class="btn" onclick="loadFromUrl()" style="width: 100%; padding: 8px;">Tải từ URL</button>
        </div>

        <input type="file" id="epubInput" class="file-input" accept=".epub">
    </div>

    <div class="header" id="header">
        <h1 id="bookTitle">EPUB Reader</h1>
        <div class="controls">
            <button class="btn" onclick="toggleSidebar()">📑</button>
            <button class="btn" onclick="toggleStats()">📊</button>
            <button class="btn" id="saveModeBtn" onclick="toggleSaveMode()" title="💾 Tiết kiệm">💾</button>
            <button class="btn" id="widthModeBtn" onclick="toggleWidthMode()" title="📐 Width">📐</button>
            <button class="btn" onclick="loadNewFile()">📂</button>
        </div>
    </div>

    <div class="stats hidden" id="stats">
        <div>📄 <span id="statLabel">Trang</span> <span id="statCurrent">0</span>/<span id="statTotal">0</span></div>
        <div>📚 <span id="statType">-</span></div>
        <div>📏 <span id="statSize">0</span> MB</div>
        <div>💾 <span id="statMemory">0</span> MB</div>
        <div>🔄 <span id="statLoaded">0</span></div>
    </div>

    <div class="viewer-container" id="viewerContainer">
        <div class="sidebar" id="sidebar">
            <h3>📑 Mục lục</h3>
            <div id="thumbnailList"></div>
        </div>

        <div class="main-viewer" id="mainViewer">
            <div class="content-container" id="contentContainer">
                <div style="text-align: center; color: #ff85a6; padding: 80px 20px;">
                    <div class="spinner"></div>
                    <p style="margin-top: 15px;">Đang tải...</p>
                </div>
            </div>
        </div>
    </div>

    <div class="footer" id="footer">
        <div class="page-info">
            <span id="footerLabel">Trang</span> <span id="currentPage">0</span> / <span id="totalPages">0</span>
        </div>
        <div class="footer-controls">
            <button class="btn" onclick="scrollToTop()">⬆️</button>
            <button class="btn" onclick="scrollToBottom()">⬇️</button>
        </div>
    </div>

    <div class="progress-bar">
        <div class="progress-fill" id="progressFill"></div>
    </div>

    <script>
        const pica = window.pica();
        
        let epubZip = null;
        let pages = [];
        let chapters = [];
        let currentPageIndex = 0;
        let loadedImages = new Map();
        let loadedPagesSet = new Set();
        let isImmersive = false;
        let epubType = 'manga';
        let fileSize = 0;
        let useLazyLoad = false;
        let saveMode = false;
        let fullWidthMode = false; // false = giới hạn width trên PC
        let imageObserver = null;

        const PRELOAD_RANGE = 4;

        const uploadOverlay = document.getElementById('uploadOverlay');
        const fileInput = document.getElementById('epubInput');

        uploadOverlay.addEventListener('click', (e) => {
            if (e.target === uploadOverlay || e.target.closest('.upload-content')) {
                fileInput.click();
            }
        });

        document.addEventListener('dragover', (e) => e.preventDefault());
        
        document.addEventListener('drop', (e) => {
            e.preventDefault();
            if (!uploadOverlay.classList.contains('hidden')) {
                const files = e.dataTransfer.files;
                if (files[0]?.name.endsWith('.epub')) {
                    loadEpub(files[0]);
                }
            }
        });

        fileInput.addEventListener('change', (e) => {
            if (e.target.files[0]) loadEpub(e.target.files[0]);
        });

        document.addEventListener('contextmenu', (e) => {
            if (!e.target.closest('.novel-chapter')) {
                e.preventDefault();
            }
        });

        let lastTap = 0;
        document.getElementById('mainViewer').addEventListener('click', (e) => {
            const now = Date.now();
            if (now - lastTap < 300) toggleImmersive();
            lastTap = now;
        });

        function toggleImmersive() {
            isImmersive = !isImmersive;
            document.getElementById('header').classList.toggle('hidden', isImmersive);
            document.getElementById('footer').classList.toggle('hidden', isImmersive);
            document.getElementById('viewerContainer').classList.toggle('immersive', isImmersive);
        }

        function toggleSaveMode() {
            saveMode = !saveMode;
            document.getElementById('saveModeBtn').classList.toggle('active', saveMode);
            
            if (useLazyLoad) {
                alert('Save mode sẽ áp dụng cho ảnh mới load');
            }
        }

        function toggleWidthMode() {
            fullWidthMode = !fullWidthMode;
            document.getElementById('widthModeBtn').classList.toggle('active', fullWidthMode);
            
            const container = document.getElementById('contentContainer');
            if (fullWidthMode) {
                container.style.maxWidth = 'none';
            } else {
                container.style.maxWidth = epubType === 'manga' ? '900px' : '900px';
            }
        }

        async function loadFromUrl() {
            const url = document.getElementById('urlInput').value.trim();
            if (!url) return alert('Vui lòng nhập URL!');
            
            try {
                uploadOverlay.classList.add('hidden');
                const response = await fetch(url);
                const blob = await response.blob();
                await loadEpub(blob);
            } catch (error) {
                alert('Lỗi: ' + error.message);
                uploadOverlay.classList.remove('hidden');
            }
        }

        function getTextContent(htmlString) {
            const doc = new DOMParser().parseFromString(htmlString, 'text/html');
            return (doc.body.textContent || '').trim();
        }

        function countWords(text) {
            return text.replace(/\s+/g, ' ').length;
        }

        async function detectEpubType(spineOrder) {
            if (fileSize > 30) {
                console.log('📦 >30MB → Manga');
                return 'manga';
            }

            let filesWithMuchText = 0;
            const samplesToCheck = Math.min(10, spineOrder.length);

            for (let i = 0; i < samplesToCheck; i++) {
                const page = spineOrder[i];
                if (!epubZip.file(page.path)) continue;

                try {
                    const content = await epubZip.file(page.path).async('string');
                    const textContent = getTextContent(content);
                    const wordCount = countWords(textContent);

                    if (wordCount > 500) filesWithMuchText++;
                    if (filesWithMuchText >= 3) {
                        console.log('📖 3+ files >500 chars → Novel');
                        return 'novel';
                    }
                } catch (error) {}
            }

            console.log('🎨 → Manga');
            return 'manga';
        }

        async function loadEpub(file) {
            try {
                uploadOverlay.classList.add('hidden');
                showLoading();
                
                fileSize = file.size / (1024 * 1024);
                useLazyLoad = fileSize > 150;
                
                epubZip = await JSZip.loadAsync(file);
                
                const opfPath = await findOpfFile();
                if (!opfPath) throw new Error('Không tìm thấy file OPF');

                const { spineOrder } = await parseOpf(opfPath);
                pages = spineOrder;
                
                epubType = await detectEpubType(spineOrder);
                chapters = await parseToc(opfPath);
                
                document.getElementById('bookTitle').textContent = file.name?.replace('.epub', '') || 'EPUB';
                document.getElementById('totalPages').textContent = pages.length;
                document.getElementById('statTotal').textContent = pages.length;
                document.getElementById('statSize').textContent = fileSize.toFixed(1);
                
                if (epubType === 'novel') {
                    document.getElementById('statLabel').textContent = 'Chương';
                    document.getElementById('footerLabel').textContent = 'Chương';
                    document.getElementById('statType').textContent = '📖 Novel';
                } else {
                    document.getElementById('statLabel').textContent = 'Trang';
                    document.getElementById('footerLabel').textContent = 'Trang';
                    document.getElementById('statType').textContent = '🎨 Manga';
                }
                
                await createViewer();
                createSidebar();
                
                hideLoading();
            } catch (error) {
                console.error('Error:', error);
                alert('Lỗi: ' + error.message);
                uploadOverlay.classList.remove('hidden');
            }
        }

        async function findOpfFile() {
            try {
                const container = await epubZip.file('META-INF/container.xml').async('string');
                const doc = new DOMParser().parseFromString(container, 'text/xml');
                const path = doc.querySelector('rootfile')?.getAttribute('full-path');
                if (path) return path;
            } catch {}

            let found = null;
            epubZip.forEach((path) => {
                if (path.endsWith('.opf') && !found) found = path;
            });
            return found;
        }

        async function parseOpf(opfPath) {
            const content = await epubZip.file(opfPath).async('string');
            const doc = new DOMParser().parseFromString(content, 'text/xml');
            const baseDir = opfPath.substring(0, opfPath.lastIndexOf('/') + 1);
            
            const manifest = {};
            doc.querySelectorAll('manifest item').forEach(item => {
                const id = item.getAttribute('id');
                const href = item.getAttribute('href');
                if (id && href) manifest[id] = baseDir + href;
            });
            
            const spineOrder = [];
            doc.querySelectorAll('spine itemref').forEach((itemref, index) => {
                const idref = itemref.getAttribute('idref');
                if (idref && manifest[idref]) {
                    spineOrder.push({
                        index,
                        path: manifest[idref],
                        id: idref,
                        element: null,
                        loaded: false
                    });
                }
            });
            
            return { spineOrder, manifest };
        }

        async function parseToc(opfPath) {
            const baseDir = opfPath.substring(0, opfPath.lastIndexOf('/') + 1);
            
            const ncxPaths = [
                baseDir + 'toc.ncx',
                'toc.ncx',
                'OEBPS/toc.ncx',
                'EPUB/toc.ncx'
            ];
            
            let foundNcx = null;
            epubZip.forEach((path) => {
                if (path.endsWith('.ncx') && !foundNcx) foundNcx = path;
            });
            if (foundNcx) ncxPaths.push(foundNcx);
            
            for (const path of ncxPaths) {
                if (epubZip.file(path)) {
                    try {
                        const content = await epubZip.file(path).async('string');
                        const doc = new DOMParser().parseFromString(content, 'text/xml');
                        
                        const chapters = [];
                        doc.querySelectorAll('navPoint').forEach(nav => {
                            const label = nav.querySelector('navLabel text')?.textContent;
                            const src = nav.querySelector('content')?.getAttribute('src');
                            
                            if (label && src) {
                                const tocDir = path.substring(0, path.lastIndexOf('/') + 1);
                                const fullPath = resolveEpubPath(tocDir + 'x', src);
                                const pageIndex = findPageIndexByPath(fullPath);
                                
                                if (pageIndex >= 0) {
                                    chapters.push({
                                        title: label,
                                        pageIndex,
                                        path: fullPath,
                                        anchor: src.includes('#') ? src.split('#')[1] : null
                                    });
                                }
                            }
                        });
                        
                        if (chapters.length > 0) return chapters;
                    } catch (e) {}
                }
            }
            
            return [];
        }

        function findPageIndexByPath(targetPath) {
            if (!targetPath) return -1;
            
            const clean = targetPath.replace(/^\/+/, '').split('#')[0];
            
            let idx = pages.findIndex(p => p.path.replace(/^\/+/, '') === clean);
            if (idx >= 0) return idx;
            
            const filename = clean.split('/').pop();
            idx = pages.findIndex(p => p.path.split('/').pop() === filename);
            
            return idx;
        }

        function resolveEpubPath(basePath, relativePath) {
            if (relativePath.startsWith('http')) return null;
            
            const path = relativePath.split('#')[0];
            const baseDir = basePath.substring(0, basePath.lastIndexOf('/') + 1);
            let resolved = baseDir + path;
            
            const parts = resolved.split('/');
            const normalized = [];
            
            for (const part of parts) {
                if (part === '..') normalized.pop();
                else if (part !== '.' && part !== '') normalized.push(part);
            }
            
            return normalized.join('/');
        }

        async function createViewer() {
            const container = document.getElementById('contentContainer');
            const mainViewer = document.getElementById('mainViewer');
            
            container.innerHTML = '';
            
            mainViewer.classList.remove('novel-mode', 'manga-mode');
            mainViewer.classList.add(`${epubType}-mode`);
            
            if (useLazyLoad && epubType === 'manga') {
                await createLazyViewer(container);
            } else {
                await createFullViewer(container);
            }
            
            setupInternalLinks();
            updateStats();
        }

        function setupInternalLinks() {
            document.getElementById('contentContainer').addEventListener('click', async (e) => {
                const link = e.target.closest('a[href]');
                if (!link) return;
                
                const href = link.getAttribute('href');
                if (href.startsWith('http://') || href.startsWith('https://')) return;
                
                e.preventDefault();
                
                let [file, anchor] = href.split('#');
                const currentPage = pages[currentPageIndex];
                
                let targetIdx = file ? findPageIndexByPath(resolveEpubPath(currentPage.path, file)) : currentPageIndex;
                
                if (targetIdx >= 0) {
                    await jumpToPage(targetIdx, anchor);
                }
            }, true);
        }

        async function createLazyViewer(container) {
            for (let i = 0; i < pages.length; i++) {
                const pageDiv = document.createElement('div');
                pageDiv.className = 'manga-page';
                pageDiv.id = `page-${i}`;
                pageDiv.dataset.index = i;
                pageDiv.dataset.loaded = 'false';
                
                const placeholder = document.createElement('div');
                placeholder.className = 'placeholder';
                placeholder.innerHTML = '<div class="spinner"></div>';
                pageDiv.appendChild(placeholder);
                
                container.appendChild(pageDiv);
                pages[i].element = pageDiv;
            }
            
            if (imageObserver) imageObserver.disconnect();
            
            imageObserver = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        loadPageWithPreload(parseInt(entry.target.dataset.index));
                    }
                });
            }, {
                root: document.getElementById('mainViewer'),
                rootMargin: '1000px'
            });
            
            pages.forEach(p => imageObserver.observe(p.element));
        }

        async function loadPageWithPreload(index) {
            await loadSinglePage(index);
            
            for (let offset = -PRELOAD_RANGE; offset <= PRELOAD_RANGE; offset++) {
                if (offset === 0) continue;
                const idx = index + offset;
                if (idx >= 0 && idx < pages.length) {
                    loadSinglePage(idx);
                }
            }
            
            unloadDistantPages(index);
        }

        async function loadSinglePage(index) {
            const page = pages[index];
            if (!page || page.loaded || loadedPagesSet.has(index)) return;
            
            loadedPagesSet.add(index);
            page.loaded = true;
            
            try {
                if (!epubZip.file(page.path)) return;

                const content = await epubZip.file(page.path).async('string');
                const doc = new DOMParser().parseFromString(content, 'text/html');
                const body = doc.querySelector('body');
                if (!body) return;
                
                await processImages(body, page.path, index);
                
                if (page.element) {
                    page.element.innerHTML = body.innerHTML;
                    page.element.dataset.loaded = 'true';
                }
                
                updateStats();
            } catch (error) {
                console.error(`Error page ${index}:`, error);
            }
        }

        function unloadDistantPages(current) {
            pages.forEach((page, idx) => {
                if (Math.abs(idx - current) > PRELOAD_RANGE * 3 && page.loaded) {
                    if (page.element?.dataset.loaded === 'true') {
                        page.element.innerHTML = '<div class="placeholder"><div class="spinner"></div></div>';
                        page.element.dataset.loaded = 'false';
                        
                        loadedImages.forEach((url, key) => {
                            if (key.startsWith(`${idx}-`)) {
                                URL.revokeObjectURL(url);
                                loadedImages.delete(key);
                            }
                        });
                        
                        page.loaded = false;
                        loadedPagesSet.delete(idx);
                    }
                }
            });
        }

        async function createFullViewer(container) {
            for (let i = 0; i < pages.length; i++) {
                const page = pages[i];
                if (!epubZip.file(page.path)) continue;

                const content = await epubZip.file(page.path).async('string');
                const doc = new DOMParser().parseFromString(content, 'text/html');
                const body = doc.querySelector('body');
                if (!body) continue;
                
                await processImages(body, page.path, i);
                
                const pageDiv = document.createElement('div');
                pageDiv.className = epubType === 'novel' ? 'novel-chapter' : 'manga-page';
                pageDiv.id = `page-${i}`;
                pageDiv.innerHTML = body.innerHTML;
                
                container.appendChild(pageDiv);
                page.element = pageDiv;
                page.loaded = true;
                loadedPagesSet.add(i);
            }
        }

        async function processImages(body, basePath, pageIndex) {
            const images = body.querySelectorAll('img');
            for (const img of images) {
                const src = img.getAttribute('src');
                if (src) await replaceImageSrc(img, src, basePath, pageIndex);
            }
            
            const svgImages = body.querySelectorAll('image[*|href], image[href]');
            for (const svgImg of svgImages) {
                const href = svgImg.getAttributeNS('http://www.w3.org/1999/xlink', 'href') || 
                             svgImg.getAttribute('href');
                
                if (href) {
                    const imagePath = resolveEpubPath(basePath, href);
                    
                    if (imagePath && epubZip.file(imagePath)) {
                        const blob = await epubZip.file(imagePath).async('blob');
                        let url;
                        
                        if (saveMode) {
                            url = await resizeImage(blob, 900);
                        } else {
                            url = URL.createObjectURL(blob);
                        }
                        
                        svgImg.setAttributeNS('http://www.w3.org/1999/xlink', 'href', url);
                        svgImg.setAttribute('href', url);
                        
                        const key = pageIndex !== undefined ? `${pageIndex}-${imagePath}` : imagePath;
                        loadedImages.set(key, url);
                    }
                }
            }
        }

        async function replaceImageSrc(img, src, basePath, pageIndex) {
            try {
                const imagePath = resolveEpubPath(basePath, src);
                
                if (imagePath && epubZip.file(imagePath)) {
                    const blob = await epubZip.file(imagePath).async('blob');
                    let url;
                    
                    if (saveMode) {
                        url = await resizeImage(blob, 900);
                    } else {
                        url = URL.createObjectURL(blob);
                    }
                    
                    img.setAttribute('src', url);
                    
                    const key = pageIndex !== undefined ? `${pageIndex}-${imagePath}` : imagePath;
                    loadedImages.set(key, url);
                } else {
                    img.style.display = 'none';
                }
            } catch (error) {
                img.style.display = 'none';
            }
        }

        async function resizeImage(blob, maxWidth) {
            return new Promise((resolve) => {
                const img = new Image();
                const url = URL.createObjectURL(blob);
                
                img.onload = async () => {
                    try {
                        if (img.width <= maxWidth) {
                            resolve(url);
                            return;
                        }
                        
                        const targetWidth = maxWidth;
                        const targetHeight = Math.round((img.height / img.width) * targetWidth);
                        
                        const canvas = document.createElement('canvas');
                        canvas.width = targetWidth;
                        canvas.height = targetHeight;
                        
                        await pica.resize(img, canvas, { quality: 3, alpha: true });
                        
                        const resizedBlob = await pica.toBlob(canvas, 'image/jpeg', 0.9);
                        URL.revokeObjectURL(url);
                        resolve(URL.createObjectURL(resizedBlob));
                    } catch (error) {
                        resolve(url);
                    }
                };
                
                img.onerror = () => {
                    URL.revokeObjectURL(url);
                    resolve('');
                };
                
                img.src = url;
            });
        }

        function createSidebar() {
            const container = document.getElementById('thumbnailList');
            container.innerHTML = '';
            
            const list = chapters.length > 0 ? chapters : pages.map((p, i) => ({ 
                title: `Trang ${i + 1}`, 
                pageIndex: i 
            }));
            
            list.forEach((item, i) => {
                const thumb = document.createElement('div');
                thumb.className = 'chapter-thumb';
                thumb.onclick = () => jumpToPage(item.pageIndex, item.anchor);
                
                const number = document.createElement('div');
                number.className = 'chapter-number';
                number.textContent = `${i + 1}`;
                
                const preview = document.createElement('div');
                preview.className = 'chapter-preview';
                preview.textContent = item.title;
                
                thumb.appendChild(number);
                thumb.appendChild(preview);
                container.appendChild(thumb);
                
                item.thumbElement = thumb;
            });
        }

        async function jumpToPage(index, anchor = null) {
            if (index < 0 || index >= pages.length) return;
            
            if (useLazyLoad) {
                await loadPageWithPreload(index);
                await new Promise(r => setTimeout(r, 300));
            }
            
            const page = pages[index];
            if (!page.element) return;
            
            page.element.scrollIntoView({ behavior: 'smooth', block: 'start' });
            updateCurrentPage(index);
            
            if (anchor) {
                await new Promise(r => setTimeout(r, 600));
                
                const el = page.element.querySelector(`#${CSS.escape(anchor)}, [id="${anchor}"]`);
                if (el) {
                    el.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    el.style.backgroundColor = 'rgba(255, 107, 157, 0.2)';
                    setTimeout(() => el.style.backgroundColor = '', 2000);
                }
            }
        }

        function updateCurrentPage(index) {
            currentPageIndex = index;
            document.getElementById('currentPage').textContent = index + 1;
            document.getElementById('statCurrent').textContent = index + 1;
            
            const progress = ((index + 1) / pages.length) * 100;
            document.getElementById('progressFill').style.width = progress + '%';
            
            document.querySelectorAll('.chapter-thumb').forEach(t => t.classList.remove('active'));
            
            if (chapters.length > 0) {
                for (let i = chapters.length - 1; i >= 0; i--) {
                    if (index >= chapters[i].pageIndex) {
                        chapters[i].thumbElement?.classList.add('active');
                        break;
                    }
                }
            } else {
                pages[index]?.thumbElement?.classList.add('active');
            }
        }

        function updateStats() {
            document.getElementById('statMemory').textContent = (loadedImages.size * 0.5).toFixed(1);
            document.getElementById('statLoaded').textContent = loadedPagesSet.size;
        }

        function toggleSidebar() {
            document.getElementById('sidebar').classList.toggle('visible');
        }

        function toggleStats() {
            document.getElementById('stats').classList.toggle('hidden');
        }

        function scrollToTop() {
            document.getElementById('mainViewer').scrollTo({ top: 0, behavior: 'smooth' });
        }

        function scrollToBottom() {
            const viewer = document.getElementById('mainViewer');
            viewer.scrollTo({ top: viewer.scrollHeight, behavior: 'smooth' });
        }

        function loadNewFile() {
            if (confirm('Tải file mới?')) {
                loadedImages.forEach(url => URL.revokeObjectURL(url));
                loadedImages.clear();
                loadedPagesSet.clear();
                pages = [];
                chapters = [];
                epubZip = null;
                uploadOverlay.classList.remove('hidden');
            }
        }

        function showLoading() {
            document.getElementById('contentContainer').innerHTML = `
                <div style="text-align: center; color: #ff85a6; padding: 80px 20px;">
                    <div class="spinner"></div>
                    <p style="margin-top: 15px;">Đang tải...</p>
                </div>
            `;
        }

        function hideLoading() {}

        let scrollTimeout;
        document.getElementById('mainViewer').addEventListener('scroll', () => {
            clearTimeout(scrollTimeout);
            scrollTimeout = setTimeout(() => {
                const viewer = document.getElementById('mainViewer');
                const rect = viewer.getBoundingClientRect();
                const centerY = rect.top + rect.height / 3;
                
                let closest = 0;
                let minDist = Infinity;
                
                pages.forEach((page, i) => {
                    if (page.element) {
                        const r = page.element.getBoundingClientRect();
                        const dist = Math.abs(r.top - centerY);
                        if (dist < minDist && r.top < centerY) {
                            minDist = dist;
                            closest = i;
                        }
                    }
                });
                
                updateCurrentPage(closest);
            }, 100);
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Home') {
                e.preventDefault();
                scrollToTop();
            } else if (e.key === 'End') {
                e.preventDefault();
                scrollToBottom();
            } else if (e.key === 'f' || e.key === 'F') {
                e.preventDefault();
                toggleImmersive();
            } else if (e.key === 's' || e.key === 'S') {
                e.preventDefault();
                toggleSidebar();
            }
        });

        setInterval(updateStats, 3000);
    </script>
</body>
</html>
